
TODO
====


+  don't require a game to have 'step skins', 'logo skins' ETC


-  CONTENTS_XXX work differently in Q1 than Q2 : unify

-  dface2_t == dface_t, move into common ??

-  replace 'equiv_id' usage with 'index'


Create "error", "missing" and "o_carve" for Half-Life (w/ palette)


Lua code to control usage of quake_tex.wd2 / hexen2_tex.wd2



QUAKE: s[] and t[] must be 4 numbers : last is ADDITION

Quake: check max size of lightmap : 16x16 or 17x17 ??

Quake: proper XY partition choice, do seed boundary thang


q1_clip : proper XY partition choice

          proper slope planes


visibility : can detect in C++ code if each seed side contains a portal
             (two-sided snag or mini side).  Hence don't need Lua API to
             communicate that information.


!!  usage of plain EPSILON


Hexen: have arg1 .. arg5, i.e. de-array-ify


-  mirroring : make sure first coord stays the first



-  global SECTIONS array


Later: fix hallways, broken due to conn(_dir) change

Later: fix Build_stairwell : broken due to conn_dir change


Monsters:
-  along = math.min(1000, info.health) ^ 0.3 * info.damage ^ 0.4 / 70

   require LEVEL.epi_along >= along

-  PARAM.episode_factor : 0 = progression continuous over whole game
                          1 = progression same in all episodes
                          (defaults to 0.5)


Quests:

-  currently broken if no switches
   -  have a lock limit, if over then mark branches as "dead_wood"
   -  keep track of number of "branches to go"



??  when to decide WOTSIT, monster and pickup spots ??

NO:  do placement allocations on a 64x64 grid



Connections:

TERMINOLOGY
  Leaf   : only one exit
  Stalk  : two exits
  Branch : three or more exits

+  plan them using sections first
   i.e. CONN = { sect1, dir, sect2 }

-  The "connect map" is the conns[] list in each room.

   -  need to allow teleporters and intrusions
   -  intrusions can be locked, teleporters cannot be

-  what makes a good set of connections?

   (1) don't exit a room on same wall as entering it
       (which has no need to traverse through the room)

   (2) T shape rooms have 3 connections in the three outer
       sections (ideally same direction as T shape)
       L shape rooms have at least 2 connects in outer tips
       plus shape rooms have 3 or 4 connections in outer tips
       Big rect rooms have 3 or 4 connections on 3/4 diff sides
       
       (same basic criterion: need to traverse the whole room)
       This trumps #1.

   (3) in small room, 3 connections is becoming too many.
       If only two, then prefer to turn 90 degrees.

   (4) need a good number of "hubs" (3 or more connections).
       
       too few  --> no locked doors are possible
       too many --> creates a lot of dead-end paths

       natural areas are most flexible

       limit on 4-exit rooms ("mega-hub") is probably: int(LEVEL.H / 2)

       for each room, count how many other rooms it touches.
       big rects or plus with >= 4 are candidates for mega-hub

   (5) the connection patterns (T, L, etc) are still a good idea for
       large rectangular rooms.  But do it using sections instead
       of seeds.

   (6) large rooms may be best as leafs (can have a big battle
       to get to the key or switch).

   (7) tiny rooms may be best as in/out (2 exit) rooms, and
       also OK for start room, and ideal for exit room when
       using a "small exit" prefab.


- Lock postponing : after decided all locked conns, pick one and
  if next room is a stalk, then can move the lock to the next
  door (and the next room becomes part of the earlier quest).


Cave code
  DONE  validate() method : check if N points (from conns) connect
     --> creates a 'flood' map
     [it should also remove other empty areas]

  DONE  find_islands() method : returns a list of new caves, one for
     each island.
     an "island" is contiguous solid area which never touches NIL.
     --> needs the flood map too

  -  re-instate size check (on main empty region), and remove the
     other empty regions.

  +  fix spot_for_wotsit

  -  furthest_point() : away from N points (conns)
     --> create a distance map

  +  fix monster spots
  +  fix pickup spots


Prefabs:
  + test if prefab fits, choose another (etc) if not

  - DOORS: have x_sizes, y_sizes, z_sizes

  - get prefab name from skin (_prefab field)

  - prepare skin table:

    1. copy it
    2. expand random selection
    3. apply prefab defaults

  - Review: allow functions in brushes or skins

  - mirroring ?!?

  - Review: material functions like get_liquid() etc


+ proper system to match DOOR skins with SWITCH skins
  (i.e. allow more than a single door or single switch per lock kind).


-  lifts often assume meshing up at 90 degree turns


FIX: shadows on outdoor crates: CRATE_W_SHADOW prefab?


+  make linedef merging more relaxed (cf. DAVID.wad)


--------------------------------------------------------------------


BUG: some Quake maps have clipping issues (invisible barriers)

BUG: switch in cave may end up inaccessible (clear the seed)

BUG: place pickups more carefully in caves (otherwise can be unpickupable)

BUG: items occasionally appear on high fences
     - finding small spots ignores sideway extents (thick[])

BUG: corner supports are sometimes off the wall


+  fix monster quantities, which was messed up by cave code.

   Also need some increase over the course of a level
   (like 50% more monsters at end compared to start) and
   vary the quantity (e.g. nothing in a room occasionally).

   For Less or Scarce settings, create smaller room palettes

-  Cave code: give each cave an 'info' field and make it a class
              with various methods, in particular for mapping
              between seed coords and cave cell coords.

+  get small exits working again
   -  rework Build_small_exit to only use a single transform

+  improve the jaggy edge algorithm (support corner triangles)

-  missing stairwells:
     The stairwell problem can be fixed by changing THEME.stairwell
     in rooms.lua to 'THEME.stairwell_walls and THEME.stairwell_floors'.


-  prevent escapes over fences/windows near key pedestals (etc) by
   raising the height of the fences/windows there.

-  some basic lighting objects (torches), esp. Urban/Hell


CSG CODE:

!!  DOOM: fix y_offset values
    (when have y_offset and brush side is truncated/extended)

-  CSG DOOM: support entity.light

-  CSG DOOM: fix up extrafloor creation

