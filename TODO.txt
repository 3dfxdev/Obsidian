
TODO
====

TEST:  CSG DOOM: temporary file has ".TMP" extension, delete it on error
       kill the temp/ folder  (NB: used by wolf too)

TEST: output file is deleted on script error.



-  Makefiles: put .o in obj_linux and obj_win32 folders


??  when to decide WOTSIT, monster and pickup spots ??

NO:  do placement allocations on a 64x64 grid



Quests:

-  Simpler method of generating the quests:

   (1) let the current room be the start room

   (2) while the current room has 2 or more free exits,
       pick one and lock it.  Traverse one of the other free
       exits until a leaf it hit, and place the key there.

   (3) iterate over the exits, recursively performing this
       algorithm on the room on the other side.  The order
       is important, it must be: the final free exit, the last
       locked exit, ..., the first locked exit.


Connections:

TERMINOLOGY
  Leaf   : only one exit
  Stalk  : two exits
  Branch : three or more exits

+  plan them using sections first
   i.e. CONN = { sect1, dir, sect2 }

-  The "connect map" is the conns[] list in each room.

   -  need to allow teleporters and intrusions
   -  intrusions can be locked, teleporters cannot be

-  what makes a good set of connections?

   (1) don't exit a room on same wall as entering it
       (which has no need to traverse through the room)

   (2) T shape rooms have 3 connections in the three outer
       sections (ideally same direction as T shape)
       L shape rooms have at least 2 connects in outer tips
       plus shape rooms have 3 or 4 connections in outer tips
       Big rect rooms have 3 or 4 connections on 3/4 diff sides
       
       (same basic criterion: need to traverse the whole room)
       This trumps #1.

   (3) in small room, 3 connections is becoming too many.
       If only two, then prefer to turn 90 degrees.

   (4) need a good number of "hubs" (3 or more connections).
       
       too few  --> no locked doors are possible
       too many --> creates a lot of dead-end paths

       natural areas are most flexible

       limit on 4-exit rooms ("mega-hub") is probably: int(LEVEL.H / 2)

       for each room, count how many other rooms it touches.
       big rects or plus with >= 4 are candidates for mega-hub

   (5) the connection patterns (T, L, etc) are still a good idea for
       large rectangular rooms.  But do it using sections instead
       of seeds.

   (6) large rooms may be best as leafs (can have a big battle
       to get to the key or switch).

   (7) tiny rooms may be best as in/out (2 exit) rooms, and
       also OK for start room, and ideal for exit room when
       using a "small exit" prefab.


- Lock postponing : after decided all locked conns, pick one and
  if next room is a stalk, then can move the lock to the next
  door (and the next room becomes part of the earlier quest).


IDEA: "crossover" room is 1x1 (perhaps 2x1) room using a 3D bridge,
      so that one path goes E/W and other path goes N/S.
      [90 degree turns are possible too, but way less cool]

      Crossovers do NOT exist as nodes in the connection map
      (they only exist as links).

      Two crossovers cannot connect to each other (because they
      would need a node between them, which doesn't exist).

      The quest of the low path is earlier than the quest of the
      high path (3D bridge).


Quests:
  +  when deciding to use keys : check for outdoor on both sides


Cave code
  DONE  validate() method : check if N points (from conns) connect
     --> creates a 'flood' map
     [it should also remove other empty areas]

  DONE  find_islands() method : returns a list of new caves, one for
     each island.
     an "island" is contiguous solid area which never touches NIL.
     --> needs the flood map too

  -  re-instate size check (on main empty region), and remove the
     other empty regions.

  +  fix spot_for_wotsit

  -  furthest_point() : away from N points (conns)
     --> create a distance map

  +  fix monster spots
  +  fix pickup spots


+ proper system to match DOOR skins with SWITCH skins
  (i.e. allow more than a single door or single switch per lock kind).


Prefabs:
  + test if prefab fits, choose another (etc) if not

  - DOORS: have x_sizes, y_sizes, z_sizes

  - DOORS: between two indoor buildings : straddle both rooms

  - get prefab name from skin (_prefab field)

  - prepare skin table:

    1. copy it
    2. expand random selection
    3. apply prefab defaults

  - Review: allow functions in brushes or skins

  - mirroring ?!?

  - Review: material functions like get_liquid() etc



-  lifts often assume meshing up at 90 degree turns


FIX: shadows on outdoor crates: CRATE_W_SHADOW prefab?


IDEA:
  - move main loop of OBLIGE into Lua (e.g. ob_main_loop)
  - C++ can queue commands to perform, fetched by the Lua loop
    (this is only mechanism for C++ to "call" Lua code)

  ? the console is a text-based interface whereas the GUI
    is the graphical interface, both using the same mechanism.

  - build the debugger using Lua


+  make linedef merging more relaxed (cf. DAVID.wad)


Console:
  +  display lists better


--------------------------------------------------------------------


BUG: some Quake maps have clipping issues (invisible barriers)

BUG: switch in cave may end up inaccessible (clear the seed)

BUG: place pickups more carefully in caves (otherwise can be unpickupable)

BUG: liquification of caves at a border can subvert quests
     >>  need to build a normal wall at sides of a connection seed
         which touch another room (or edge of map).

BUG: items occasionally appear on high fences
     - finding small spots ignores sideway extents (thick[])

BUG: corner supports are sometimes off the wall


+  fix monster quantities, which was messed up by cave code.

   Also need some increase over the course of a level
   (like 50% more monsters at end compared to start) and
   vary the quantity (e.g. nothing in a room occasionally).

   For Less or Scarce settings, create smaller room palettes

-  Cave code: give each cave an 'info' field and make it a class
              with various methods, in particular for mapping
              between seed coords and cave cell coords.

+  get small exits working again
   -  rework Build_small_exit to only use a single transform

+  improve the jaggy edge algorithm (support corner triangles)

-  missing stairwells:
     The stairwell problem can be fixed by changing THEME.stairwell
     in rooms.lua to 'THEME.stairwell_walls and THEME.stairwell_floors'.


-  prevent escapes over fences/windows near key pedestals (etc) by
   raising the height of the fences/windows there.

-  some basic lighting objects (torches), esp. Urban/Hell

DONE:  have a 'functions' table for games, engines, mods 
   e.g. setup_func = XXX  -->  functions = { setup = XXX }

-  cmdline option: -k (--keep-seed)


CSG CODE:

+  improve progress bar code to handle Lua part + CSG part
   (especially for Quake)

DONE(?)  replace 'line_kind' and 'sec_kind' with just 'kind' in area_face_c
         (similarly for 'tag', 'args' etc...).
         Put delta_z in there too.

DONE(?)  make the [wbt]_face field of brushes be like entities and
         store all the fields in a std::map.
         Have a utility function to find / extract a field.

!!  do a proper face-creation pass (merge_face_c list
    in each merge_segment_c ?) and get proper brush
    and area_vert references.

    Hence remove the CSG2_FindXXX rubbish.

!!  DOOM: fix y_offset values
    (when have y_offset and brush side is truncated/extended)

-  CSG DOOM: support entity.light

-  CSG DOOM: fix up extrafloor creation

-  Rail brushes: support fake 3D bridges
                 (create dummy sector from brush's Z2)

q1_nodes:
  -  floor_leaf --> leaf
  ?? move floor/ceiling faces into leaf.faces (instead of leaf.floor)

